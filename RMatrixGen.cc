/*
#############################################################################

RMatrixGen(eration)

Arthur Zangi (szangi@mit.edu)
08-16-2024

16 AUG 24 (original)

This code is intended to provide the bare bones necessary to simulate a 
white beam of neutrons striking a detector of specified material and geometric
configuration, and record the light reponse as a function of neutron energy,
to enable the fast, and flexible generation of the detector response (R)
matrix. 

It is NOT intended for efficiency calculations, or for simulating photon
detection, as the optical photons are killed immediately after they are
recorded. 

Much of the geometry specification code is adapted from a code written by
Zach Hartwig (ScintEval), which uses ASIM to model detector response, and 
the efficiency calculations for neutron spectrum unfolding are intended to
be generated by that code. 
############################################################################
*/

// G4 Header Files
#include "G4RunManager.hh" 
#include "G4VisExecutive.hh"
#include "G4UImanager.hh"
#include "G4UIExecutive.hh"
#include "G4UIterminal.hh"
#include "G4UItcsh.hh"
#include "QGSP_BIC.hh"
#include "QGSP_BIC_AllHP.hh"
#include "QBBC.hh"
#include "G4TrajectoryDrawByParticleID.hh"
#include "G4GenericBiasingPhysics.hh"

#include <iostream>

// User Header Files
#include "geometryConstruction.hh"
#include "PGA.hh"
#include "runAction.hh"
#include "eventAction.hh"
#include "stackingAction.hh"
#include "PhysicsList.hh"

int main(int argc, char *argv[])
{
  // Use the current time to seed the RNG unless overridden 
  if(argc>1){
    std::string arg1 = argv[1];
    if(arg1 != "-0")
      CLHEP::HepRandom::setTheSeed(time(0));
  }
  // Create a runManager to handle the flow of operations in the program.  
  G4RunManager* runManager = new G4RunManager;

  // Create new "mandatory defined" class objects and tell the
  // runManager to initialize them for use
  runManager -> SetUserInitialization(new geometryConstruction);
  // new physics list with individual lists registered for different processes
  // QBBC* physicsList = new QBBC; //QBBC is the recommended list for thin target high precision modelling
   PhysicsList *physicsList = new PhysicsList();

  runManager -> SetUserInitialization(physicsList->GetPhysicsList());
  
  runManager -> SetUserAction(new PGA);
  
  runAction *rnAction = new runAction;
  runManager -> SetUserAction(rnAction);

  // Create new "user defined" class objects and tell the runManager
  // to initialize them for use
  eventAction *evtAction = new eventAction();
  runManager -> SetUserAction(evtAction);  

  stackingAction *stackAction = new stackingAction(evtAction);
  runManager -> SetUserAction(stackAction);
  
  runManager -> Initialize();
  
  // If the shell variable for visualization use is set, then create a
  // manager to handle the visualization processes  
  G4VisManager* visManager = new G4VisExecutive("errors");
  visManager -> Initialize();
  G4TrajectoryDrawByParticleID* model = new G4TrajectoryDrawByParticleID;
  visManager->RegisterModel(model);
  visManager->SelectTrajectoryModel(model->Name());

  // Get the U(ser)I(interface) pointer to allow...*suspense*
  // ...user interface!
  G4UImanager* UI = G4UImanager::GetUIpointer();
  if (argc == 1)
  {
    // Create a modern UI interface with embedded OpenGL graphics
    G4UIExecutive *UIExecutive = new G4UIExecutive(argc, argv, "Qt");
    UI-> ApplyCommand("/control/execute RMatrixGen.vis"); 
    UI -> ApplyCommand("/run/verbose 1");
    UI -> ApplyCommand("/event/verbose 0");
    UI -> ApplyCommand("/hits/verbose 0");
    UI -> ApplyCommand("/tracking/verbose 0");
    UI -> ApplyCommand("/tracking/storeTrajectory 0");

    UIExecutive -> SessionStart();

    // Make sure to "delete" anything that we have create above using
    // "new".  This is good memory management

    delete UIExecutive;
    delete UI;
  }
  else{
    G4String command = "/control/execute ";
    G4String fileName;
    if (argc ==2){
      fileName = argv[1];
      }
    else{
       fileName = argv[2];
      }
    
    UI->ApplyCommand(command+fileName);
  }

  delete visManager;
  delete runManager;
  
  return 0;
}

